-- automatically generated by BNF Converter
module Main where


  import System.IO ( stdin, hGetContents, stderr, hPutStrLn )
  import System.Environment ( getArgs, getProgName )
  
  import Lexgramm
  import Pargramm
  import Skelgramm
  import Printgramm
  import Absgramm
  import TypeCheck
  import Common
  import qualified Interpreter as I
  import Control.Monad

  import ErrM
  
  type ParseFun a = [Token] -> Err a
  
  myLLexer = myLexer
  
  type Verbosity = Int

  putStrLnErr = hPutStrLn stderr
  
  putStrV :: Verbosity -> String -> IO ()
  putStrV v s = when (v > 1) $ putStrLn s
  
  runFile :: (Print a, Show a) => Verbosity -> ParseFun a -> FilePath -> IO ()
  runFile v p f = putStrLn f >> readFile f >>= run v p
  
  run :: (Print a, Show a) => Verbosity -> ParseFun a -> String -> IO ()
  run v p s = let ts = myLLexer s in case p ts of
             Bad s    -> do putStrLn "\nParse              Failed...\n"
                            putStrV v "Tokens:"
                            putStrV v $ show ts
                            putStrLn s
             Ok  tree -> do putStrLn "\nParse Successful!"
                            showTree v tree
  
  checkTypesP::ParseFun Prog -> FilePath -> IO()
  checkTypesP p f = do 
      cont <- putStrLn f >> readFile f  
      let ts = myLLexer cont
      case p ts of
        Ok tree -> do
                    r <- checkType tree initialEnv
                    case r of
                        Left e -> putStrLn e
                        _ -> return ()
        _ -> putStrLn "error parsing"
  
  
  interpret::ParseFun Prog -> FilePath -> IO()
  interpret p f = do
    checkTypesP p f
    cont <- putStrLn f >> readFile f  
    let ts = myLLexer cont
    case p ts of
        Ok tree -> do 
                    r <- I.interpret tree initialEnv
                    case r of 
                      Left e -> putStrLnErr e
                      _ -> return ()
        _ -> return ()
  
  showTree :: (Show a, Print a) => Int -> a -> IO ()
  showTree v tree
   = do
        putStrV v $ "\n[Abstract Syntax]\n\n" ++ show tree
        putStrV v $ "\n[Linearized tree]\n\n" ++ printTree tree
  
  fullInterpret::ParseFun Prog -> FilePath -> IO() 
  fullInterpret p f = do 
          s <- readFile f 
          let ts = myLLexer s in case p ts of 
            Bad s    -> do putStrLnErr "\nParse Failed...\n" 
                           putStrLnErr s 
            Ok  tree -> do 
                           r <- checkType tree initialEnv 
                           case r of 
                            Left e -> putStrLnErr e 
                            _ -> do  
                                  r <- I.interpret tree initialEnv 
                                  case r of  
                                    Left e -> putStrLnErr e 
                                    _ -> return () 
  

  main :: IO ()
  main = do args <- getArgs
            case args of
              [] -> hGetContents stdin >>= run 2 pProg
              "-s":fs -> mapM_ (runFile 0 pProg) fs
              "-t":fs -> mapM_ (checkTypesP pProg) fs
              fs -> mapM_ (fullInterpret pProg) fs
  