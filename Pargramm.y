-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Pargramm where
import Absgramm
import Lexgramm
import ErrM

}

%name pListDeclaration ListDeclaration
%name pListFuncParam ListFuncParam
%name pListExpr ListExpr
%name pListFieldDecl ListFieldDecl
%name pListTypeIdent ListTypeIdent
%name pListStmt ListStmt
%name pProg Prog
%name pDeclaration Declaration
%name pFuncDecl FuncDecl
%name pFieldDecl FieldDecl
%name pTypeIdent TypeIdent
%name pFuncParam FuncParam
%name pRef Ref
%name pVarDecl VarDecl
%name pInitExpr InitExpr
%name pStmt Stmt
%name pElseStmt ElseStmt
%name pBindExpr BindExpr
%name pForInit ForInit
%name pExpr Expr
%name pExpr1 Expr1
%name pExpr2 Expr2
%name pExpr3 Expr3
%name pExpr4 Expr4
%name pFuncInvoke FuncInvoke

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token 
 '!' { PT _ (TS _ 1) }
 '!=' { PT _ (TS _ 2) }
 '%' { PT _ (TS _ 3) }
 '&&' { PT _ (TS _ 4) }
 '(' { PT _ (TS _ 5) }
 ')' { PT _ (TS _ 6) }
 '*' { PT _ (TS _ 7) }
 '+' { PT _ (TS _ 8) }
 ',' { PT _ (TS _ 9) }
 '-' { PT _ (TS _ 10) }
 '.' { PT _ (TS _ 11) }
 '/' { PT _ (TS _ 12) }
 ';' { PT _ (TS _ 13) }
 '<' { PT _ (TS _ 14) }
 '<=' { PT _ (TS _ 15) }
 '=' { PT _ (TS _ 16) }
 '==' { PT _ (TS _ 17) }
 '>' { PT _ (TS _ 18) }
 '>=' { PT _ (TS _ 19) }
 'Array' { PT _ (TS _ 20) }
 'Func' { PT _ (TS _ 21) }
 '[' { PT _ (TS _ 22) }
 ']' { PT _ (TS _ 23) }
 'bool' { PT _ (TS _ 24) }
 'break' { PT _ (TS _ 25) }
 'char' { PT _ (TS _ 26) }
 'continue' { PT _ (TS _ 27) }
 'else' { PT _ (TS _ 28) }
 'false' { PT _ (TS _ 29) }
 'for' { PT _ (TS _ 30) }
 'if' { PT _ (TS _ 31) }
 'int' { PT _ (TS _ 32) }
 'new' { PT _ (TS _ 33) }
 'ref' { PT _ (TS _ 34) }
 'return' { PT _ (TS _ 35) }
 'string' { PT _ (TS _ 36) }
 'struct' { PT _ (TS _ 37) }
 'true' { PT _ (TS _ 38) }
 'void' { PT _ (TS _ 39) }
 'while' { PT _ (TS _ 40) }
 '{' { PT _ (TS _ 41) }
 '||' { PT _ (TS _ 42) }
 '}' { PT _ (TS _ 43) }

L_ident  { PT _ (TV $$) }
L_integ  { PT _ (TI $$) }
L_charac { PT _ (TC $$) }
L_quoted { PT _ (TL $$) }
L_err    { _ }


%%

Ident   :: { Ident }   : L_ident  { Ident $1 }
Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Char    :: { Char }    : L_charac { (read ( $1)) :: Char }
String  :: { String }  : L_quoted {  $1 }

ListDeclaration :: { [Declaration] }
ListDeclaration : Declaration { (:[]) $1 } 
  | Declaration ListDeclaration { (:) $1 $2 }


ListFuncParam :: { [FuncParam] }
ListFuncParam : {- empty -} { [] } 
  | FuncParam { (:[]) $1 }
  | FuncParam ',' ListFuncParam { (:) $1 $3 }


ListExpr :: { [Expr] }
ListExpr : {- empty -} { [] } 
  | Expr { (:[]) $1 }
  | Expr ',' ListExpr { (:) $1 $3 }


ListFieldDecl :: { [FieldDecl] }
ListFieldDecl : FieldDecl { (:[]) $1 } 
  | FieldDecl ListFieldDecl { (:) $1 $2 }


ListTypeIdent :: { [TypeIdent] }
ListTypeIdent : {- empty -} { [] } 
  | ListTypeIdent TypeIdent ',' { flip (:) $1 $2 }


ListStmt :: { [Stmt] }
ListStmt : {- empty -} { [] } 
  | ListStmt Stmt { flip (:) $1 $2 }


Prog :: { Prog }
Prog : ListDeclaration { DProg $1 } 


Declaration :: { Declaration }
Declaration : FuncDecl { DFunc $1 } 
  | VarDecl { DVarDecl $1 }
  | 'struct' Ident '{' ListFieldDecl '}' { DStructDecl $2 $4 }


FuncDecl :: { FuncDecl }
FuncDecl : TypeIdent Ident '(' ListFuncParam ')' '{' ListStmt '}' { SFuncDecl $1 $2 $4 (reverse $7) } 


FieldDecl :: { FieldDecl }
FieldDecl : TypeIdent Ident ';' { SFieldDecl $1 $2 } 


TypeIdent :: { TypeIdent }
TypeIdent : 'int' { TInt } 
  | 'bool' { TBool }
  | 'char' { TChar }
  | 'string' { TString }
  | 'void' { TVoid }
  | Ident { TStruct $1 }
  | 'Func' '<' ListTypeIdent TypeIdent '>' { TFunc (reverse $3) $4 }
  | 'Array' '<' TypeIdent '>' { TArray $3 }


FuncParam :: { FuncParam }
FuncParam : Ref TypeIdent Ident { SFuncParam $1 $2 $3 } 


Ref :: { Ref }
Ref : 'ref' { SRef } 
  | {- empty -} { SNRef }


VarDecl :: { VarDecl }
VarDecl : TypeIdent Ident InitExpr ';' { SVarDecl $1 $2 $3 } 


InitExpr :: { InitExpr }
InitExpr : {- empty -} { ENonInit } 
  | '=' Expr { EValInit $2 }


Stmt :: { Stmt }
Stmt : VarDecl { SVarDeclS $1 } 
  | BindExpr '=' Expr ';' { SValAssign $1 $3 }
  | 'while' '(' Expr ')' '{' ListStmt '}' { SWhileS $3 (reverse $6) }
  | 'for' '(' ForInit Expr ';' BindExpr '=' Expr ')' '{' ListStmt '}' { SForS $3 $4 $6 $8 (reverse $11) }
  | 'if' '(' Expr ')' '{' ListStmt '}' ElseStmt { SIfS $3 (reverse $6) $8 }
  | FuncInvoke ';' { SFuncInvS $1 }
  | 'return' Expr ';' { SReturnExpr $2 }
  | 'return' ';' { SReturn }
  | 'break' ';' { SBreak }
  | 'continue' ';' { SContinue }


ElseStmt :: { ElseStmt }
ElseStmt : 'else' '{' ListStmt '}' { SElse (reverse $3) } 
  | {- empty -} { SElseEmpty }


BindExpr :: { BindExpr }
BindExpr : Ident { EBVar $1 } 
  | BindExpr '.' Ident { EFldAccs $1 $3 }
  | BindExpr '[' Expr ']' { EArrAccs $1 $3 }


ForInit :: { ForInit }
ForInit : VarDecl { SForInit $1 } 
  | ';' { SSkip }


Expr :: { Expr }
Expr : Expr '+' Expr1 { EAdd $1 $3 } 
  | Expr '-' Expr1 { ESub $1 $3 }
  | Expr '||' Expr1 { EOr $1 $3 }
  | Expr1 { $1 }


Expr1 :: { Expr }
Expr1 : Expr1 '*' Expr2 { EMul $1 $3 } 
  | Expr1 '/' Expr2 { EDiv $1 $3 }
  | Expr1 '%' Expr2 { EMod $1 $3 }
  | Expr1 '&&' Expr2 { EAnd $1 $3 }
  | Expr2 { $1 }


Expr2 :: { Expr }
Expr2 : Expr2 '==' Expr3 { EEq $1 $3 } 
  | Expr2 '!=' Expr3 { ENeq $1 $3 }
  | Expr2 '<' Expr3 { ELt $1 $3 }
  | Expr2 '>' Expr3 { EGt $1 $3 }
  | Expr2 '<=' Expr3 { ELEt $1 $3 }
  | Expr2 '>=' Expr3 { EGEt $1 $3 }
  | Expr3 { $1 }


Expr3 :: { Expr }
Expr3 : '!' Expr3 { EBNeg $2 } 
  | Expr4 { $1 }


Expr4 :: { Expr }
Expr4 : BindExpr { EBindEx $1 } 
  | Integer { EInt $1 }
  | Char { EChar $1 }
  | String { EString $1 }
  | 'true' { ETrue }
  | 'false' { EFalse }
  | '(' Expr ')' { $2 }
  | 'new' TypeIdent '[' Expr ']' { EArrCr $2 $4 }
  | FuncInvoke { EFuncInvoke $1 }


FuncInvoke :: { FuncInvoke }
FuncInvoke : Ident '(' ListExpr ')' { FFuncInvoke $1 $3 } 



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

